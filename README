# Proctal

Manipulates the address space of a running program on Linux.

Comes with a command line interface and a C library.


## Example

### CLI

Having acquired the right permissions to fiddle with running programs (root):

	$ proctal read 22002 1803acc
	123
	$ proctal write 22002 1803acc 124
	$ proctal read 22002 1803acc
	124

### C library

Linking dynamically or statically to libproctal:

	// Declares the libraries' functions.
	#include <proctal.h>

	int main (int argc, char **argv)
	{
		int val;

		// Attempting to read an int from an other process.
		if (proctal_read_int(22002, (void *) 0xBEEF, &val) != 0) {
			return 1; // Failed to read.
		}

		val += 1;

		// Attempting to write an int to an other process.
		if (proctal_write_int(22002, (void *) 0xBEEF, val) != 0) {
			return 1; // Failed to write.
		}

		return 0;
	}


## Usage

### CLI

Command used to read a value:

	$ proctal read [options] <pid> <address>

Command used to write a value:

	$ proctal write [options] <pid> <address> <value>

Passing --help in [options] will print more usage details.


### C library

Can be used by linking to libproctal and including proctal.h

Available functions are documented in the header file.


## Installation

Proctal provides a 3 step installation process employed by many C/C++ programs
on Linux:

	$ ./configure
	$ make
	$ make install

The configure script allows you to define how you want Proctal to be compiled
and installed. For more information type `./configure -h`.


## Development

Proctal uses the autotools to generate build systems for UNIX like operating
systems. I will provide instructions on how to get you quickly started to
generate a development build.

To get the autotools ready for use, you will need to run `autoreconf` with the
`-i` option:

	$ autoreconf -i

You will notice that now there are new files and directories in the project.
These were generated by `autoreconf` and can be ignored.

With the tools ready to use, you can now generate a build. I recommend using
various build directories for different purposes. Here's how you can create a
build that surpresses optimizations and adds debugging symbols:

	$ mkdir -p build/debug
	$ cd build/debug
	$ ../../configure 'CFLAGS=-g -O0'

So with a build system in place, you can now start compiling by running the
`make` command in your build directory:

	$ make

If you modify a source file and run `make` again it should detect the change
and recompile again.

For tinkering with the source code this is enough. For more details on what
you can do with the autotools read the manuals over at gnu.org.[1]


## License

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

[1]: https://www.gnu.org/software/
